---
title: "Metadata format: detailed"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Metadata format: detailed}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

some [text]{style="background-color: blue"}

## Design principles

`epicdata` wants to be a user-friendly, yet comprehensive data processing and cleaning tool for all types of epidemiological studies. We therefore adhere to the following design principles:

-   Modular workflow: `epicdata` follows a data processing workflow (see [here]{style="background-color: blue"} for details) but you can choose, which workflow modules you need.
-   Metadata as only input: `epicdata` creates your processing code from the metadata alone. Your individual workflow is concluded from your metadata. If you, e.g., don't specify any contradictions, `epicdata` will skip contradiction checks.
-   Modular metadata: You only specify what you need. If you have no date variables, there's no need to specify a date format.
-   Forgiving: Whenever possible, metadata can be specified in different ways to remove barriers in metadata creation. Did you forget if you need to specify date.format or format.date? No problem, `epicdata` understands both.
-   Complete logging: Data cleaning will lead to changes in individual data values. `epicdata` logs every single change that is made throughout the cleaning process.
-   Automate as much as possible: The user only needs to provide metadata and decide what to do with problematic data values. `epicdata` creates the code, applies your decisions, and creates a data dictionary.
-   Interactive: Even though `epicdata` automates as much as possible, it is still run interactively, i.e., while the user is on the other side of the keyboard. During the process, the user needs to confirm the results of different workflow steps. If you are looking for a automated data validation process, try packages `pointblank` or `dataquieR`.
-   Usable for non-veteran R users: Metadata is specified in human readable YAML format. `epicdata` creates R code. User decisions can be inputted in user-friendly ways.

## Format (YAML)

In `epicdata`, metadata is specified in **YAML** format. YAML has been designed to be readable for both humans and computers. This is accomplished by **indentations**, i.e., the distance a line of text is moved towards the right. The indentation thereby defines a hierarchy of the individual elements. In other formats, such a hierarchy needs additional text elements, which hurts human readability. This means, however, that errors in indentations will lead to misspecification of metadata information. (Usually, the next layer is 2 spaces or a tab towards the right.)

``` yaml
First.layer
  Second.layer
  Second.layer
    Third.layer
  Second.layer
First.layer
  Second.layer
```

Colons `:` are used to specify **key-value pairs**, i.e., an element of a certain name (key) as well as its corresponding value. Per line, only one key-value pair is specified. The basic syntax is `key: value`. Always include a space after the colon. Usually no quotation marks `""` are necessary when specifying values. In the rare occasion when quotation marks are necessary, `epicmodel` will tell you so. Almost all keys are pre-defined by `epicdata` to structure your metadata. The values usually must have a specific format, e.g. a number, or come from a list of allowed values. The values `yes` and `no` (similarly to `true` and `false`) will be transformed to `TRUE` and `FALSE` in R.

``` yaml
name: France
capital: Paris
population.million: 68
eu.member: yes
```

Dashes `-` are used to form **lists**, either of values without any keys, or of a repeating set of key-value pairs. All values or key-value pairs in the same list need to have the same indentation. In a list of values without keys, all of them have a dash. In a list of key-value pairs, several key-value pairs together describe an individual object. The keys repeat for every new object. Only the first key-value pair has a dash. Note that in the example below `continents` and `countries` are on the first layer, while all other lines are on the second layer. Therefore, e.g., `name: France` and `capital: Paris` have the same indentation even though `name: France` has the additional dash.

``` yaml
continents:
- Africa
- Asia
- Europe
countries:
- name: France
  capital: Paris
  population.million: 68
  eu.member: yes
- name: Germany
  capital: Berlin
  population.million: 84
  eu.member: yes
```

## Metadata design principles

-   Including a key without specifying a value is equal to not including the key at all.

``` yaml
options:
  study.name: epicdata
  id.var:
  load.from: folder
```

is equal to

``` yaml
options:
  study.name: epicdata
  load.from: folder
```

-   Not specifying a key contains information for some keys as it defaults to a pre-specified value. (See the end of this vignette for a complete list of defaults.)

-   Whenever useful, different spellings are offered, e.g., `date.format` and `format.date`.

## Components

In `epicdata`, metadata consists of several components:

-   `options`: A list of options specifying study information, e.g. `study.name`, selecting workflow modules, e.g. `double.entry`, and defining global variable defaults, e.g. `date.format`.
-   `var.list`: A list of all variables, where variable-specific information is specified.
-   `na.codes`: A list of codes that will represent missing values in the processed data set.
-   `na.rules`: A list of conditions that define which na.code will be used in which situation.
-   `contras`: A list of implausible combinations of values from two variables.

The components form the first layer of the metadata hierarchy. They are the only values specified in the first layer. Specify them with a colon and without any dashes. The components can be specified in any order. If you are not adding any values below a certain component, you can leave it out completely.

``` yaml
options:
  tbd
var.list:
  tbd
na.codes:
  tbd
na.rules:
  tbd
contras:
  tbd
```

## Component: options

Options are key-value pairs below component `options`. List all key-value pairs on the second layer without any dashes. In the list of option keys below, allowed values for the corresponding key are found in the brackets after each key.

**Study information**

-   `study.name` (Text): A short name for your study that is used for project and file names. If missing, a generic name will be used instead.

-   `id.var` (Value of key `id` from `var.list`): The name of the ID variable, which is used to identify observations. Allowed are the variable names specified in `var.list` as `id`. Duplicate values in the ID variable are allowed only if `double.entry: yes`. If missing, a generic ID variable will be added temporarily. Mandatory when `double.entry: yes` or `id.pattern` has been specified.

-   `id.pattern` (Regular expression): A regex pattern that must be fulfilled for all values of the variable specified in `id.var`. Rows with non-matching IDs are excluded. **Surround with quotation marks**, e.g., `"[:digit:]{5}"`!

**Workflow module selection**

-   `id.list` ((boolean, i.e., `true`, `yes`, `false`, `no`):

-   `load.from` (one of: `folder`, `db`): Defines which code module for reading raw data is used. If `folder`, data is read from the `Input` folder in the project. If `db`, data is read from a database. If missing, defaults to `folder`.

-   `mc.handling` ():

-   `double.entry` (boolean, i.e., `true`, `yes`, `false`, `no`):

**Global variable defaults**

-   `date.format` or `format.date` (one of: `ymd`, `ydm`, `mdy`, `myd`, `dmy`, `dym`): Defines the default date format. The value specified here is used for all variables of `type: date` for which no individual `format` is defined in `var.list`. If all date variables have a format defined, `date.format` has no impact. In `epicdata`, `lubridate` functions are used to process dates. The possible values define the order of day (d), month (m) and year (y). See `lubridate::ymd()` for possible date formats that can be processed with these functions. Mandatory when there are variables of `type: date` and not all of them have key `format` defined in `var.list`. Do not use both `date.format` and `format.date`.

-   `time.format` or `format.time` (one of: `hms`, `hm`, `ms`):

-   `datetime.format` or `format.datetime` (one of: ):

-   `to.na` (Text):

-   `touch.na` (boolean, i.e., `true`, `yes`, `false`, `no`):

-   `to.factor` (boolean, i.e., `true`, `yes`, `false`, `no`):

``` yaml
options:
  study.name: epicdata
  id.var: id
  id.pattern: "[:digit:]{5}"
  date.format: dmy
```

## Component: var.list

The list of variables `var.list` is the core of the metadata and a mandatory part of it. List all key-value pairs on the second layer. The same keys are re-used for each variable. Use a dash for only the first key of every new variable. In the list of variable keys below, allowed values for the corresponding key are found in the brackets after each key. Many keys only apply to certain variable types. Do not specify keys that apply to other types of variables. The list below is structured by the type of variable the keys apply to.

**Keys that apply to all variables:**

-   `id` (a syntactically valid name, see `?make.names` for details): The name of the variable. `id` must be specified for every variable. All variable names in the data set must be specified either in `id` or in `old.id`.

-   `old.id` or `id.old` (a syntactically valid name, see `?make.names` for details): If you want to change the name of a variable, put the old name in `old.id` and the new name in `id`. All variable names in the data set must be specified either in `id` or in `old.id`. Cannot be used together with `new`.

-   `label` (Text):

-   `label.eng` (Text): If the label is not in English, enter its English translation here for use in the data dictionnary.

-   `type` (one of: `text`, `cat`, `num`, `date`, `time`, `datetime`):

-   `na.else` (a missing code): The missing code (as defined in component `na.codes`) specified here is used to replace `NA`s if no rule in `na.rules` applies. Must be specifed always, apart from situations when the variable has no `NA`s or when `touch.na` is set to `no`.

-   `to.na` (text):

-   `touch.na` (boolean, i.e., `true`, `yes`, `false`, `no`): If `no`, all `NA`s, after applying `to.na`, will remain as `NA`. If `yes`, `NA`s are processed as usual. Defaults to the global option `touch.na`, or, if the global options has not been specified, to `yes`.

-   `new` (): Create new variables based on existing variables by specifying `new`. If `new` is specified, `id` must not be in the data set. Also, `old.id` cannot be used. New variables are created with `dplyr::mutate()`, where the variable definition is specified as a name-value pair using tidy evaluation with data masking. For `new`, specify the value of this name-value pair. As an example, variable `mass_norm` would be created by `data.frame %>% mutate(mass_norm = mass / mean(mass, na.rm = TRUE))`. To recreate the creation of `mass_norm` in `epicdata`, `mass` must be a variable specified in `var.list`, `mass_norm` is the value for `id` for your new variable, while `mass / mean(mass, na.rm = TRUE)` is specified for `new`. If your value causes an error, try to wrap it in quotation marks.

``` yaml
var.list:
- id: mass
  ...
- id: mass_norm
  ...
  new: mass / mean(mass, na.rm = TRUE)
```

**Text variables:**

-   `ops` (a variable or mc.set name):
-   `dict` ():

**Categorical (cat) variables:**

-   `cats` ():

-   `cats.eng` ():

-   `to.factor` (boolean, i.e., `true`, `yes`, `false`, `no`): If `yes`, tranforms the variable to factor.

-   `factor.id` or `id.factor` (): If `to.factor` is `yes` or not specified, a new variable is created and turned to factor while this variable stays integer. Provide the name of the new factor variable.

-   `mc.set` (a syntactically valid name, see `?make.names` for details): cannot be a value used in any `id.var`,

**Numeric (num) variables:**

-   `from` ():

-   `from.exclude` ():

-   `to` ():

-   `to.exclude` ():

**Date variables:**

-   `format` or `date.format` or `format.date` ():

-   `from` ():

-   `from.exclude` ():

-   `to` ():

-   `to.exclude` ():

**Time variables:**

-   `format` or `time.format` or `format.time` ():

-   `from` ():

-   `from.exclude` ():

-   `to` ():

-   `to.exclude` ():

**Datetime variables:**

-   `format` or `datetime.format` or `format.datetime` ():

-   `from` ():

-   `from.exclude` ():

-   `to` ():

-   `to.exclude` ():

``` yaml
var.list:
- id:
  label:
```

## Defaults

Defaults are the values that are used if the key is not specified at all. Not all keys have defaults.

### options

| Key | Default |
|----|----|
| `study.name` | `my_study` |
| `id.var` | `id.var` (with values 1:N) |
| `id.pattern` | \- |
| `id.list` | `no` |
| `load.from` | `folder` |
| `consent` | `yes`, if `id.var` has been specified, otherwise `no` |
| `mc.handling` | `none` |
| `double.entry` | `no` |
| `date.format` or `format.date` | \- |
| `time.format` or `format.time` | \- |
| `datetime.format` or `format.datetime` | \- |
| `to.na` | \- |
| `touch.na` | `yes` |
| `to.factor` | `no` |

### var.list

| Key | Default |
|------------------------------------|------------------------------------|
| `id` | \- |
| `old.id` | \- |
| `label` | \- |
| `label.eng` | \- |
| `type` | \- |
| `na.else` | \- |
| `to.na` | option `to.na` |
| `touch.na` | option `touch.na` |
| `new` | \- |
| `ops` | `no` |
| `cats` | \- |
| `cats.eng` | \- |
| `to.factor` | yes, if `factor.id` or `id.factor` has been speceified, otherwise option `to.factor` |
| `factor.id` or `id.factor` | \- |
| `from` | $-\infty$ (number, date, time, or datetime) |
| `from.exclude` | $-\infty$ (number, date, time, or datetime) |
| `to` | $\infty$ (number, date, time, or datetime) |
| `to.exclude` | $\infty$ (number, date, time, or datetime) |
| `format` or `date.format` or `format.date` | option `date.format` or `format.date` |
| `format` or `time.format` or `format.time` | option `time.format` or `format.time` |
| `format` or `datetime.format` or `format.datetime` | option `datetime.format` or `format.datetime` |
