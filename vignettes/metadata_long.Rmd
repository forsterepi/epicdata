---
title: "Metadata format: detailed"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Metadata format: detailed}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

some [text]{style="background-color: blue"}

## Design principles

`epicdata` wants to be a user-friendly, yet comprehensive data processing and cleaning tool for all types of epidemiological studies. We therefore adhere to the following design principles:

-   Modular workflow: `epicdata` follows a data processing workflow (see [here]{style="background-color: blue"} for details) but you can choose, which workflow modules you need.
-   Metadata as only input: `epicdata` creates your processing code from the metadata alone. Your individual workflow is concluded from your metadata. If you, e.g., don't specify any contradictions, `epicdata` will skip contradiction checks.
-   Modular metadata: You only specify what you need. If you have no date variables, there's no need to specify a date format.
-   Forgiving: Whenever possible, metadata can be specified in different ways to remove barriers in metadata creation. Did you forget if you need to specify date.format or format.date? No problem, `epicdata` understands both.
-   Complete logging: Data cleaning will lead to changes in individual data values. `epicdata` logs every single change that is made throughout the cleaning process.
-   Automate as much as possible: The user only needs to provide metadata and decide what to do with problematic data values. `epicdata` creates the code, applies your decisions, and creates a data dictionary.
-   Interactive: Even though `epicdata` automates as much as possible, it is still run interactively, i.e., while the user is on the other side of the keyboard. During the process, the user needs to confirm the results of different workflow steps. If you are looking for a automated data validation process, try packages `pointblank` or `dataquieR`.
-   Usable for non-veteran R users: Metadata is specified in human readable YAML format. `epicdata` creates R code. User decisions can be inputted in user-friendly ways.

## Format (YAML)

In `epicdata`, metadata is specified in **YAML** format. YAML has been designed to be readable for both humans and computers. This is accomplished by **indentations**, i.e., the distance a line of text is moved towards the right. The indentation thereby defines a hierarchy of the individual elements. In other formats, such a hierarchy needs additional text elements, which hurts human readability. This means, however, that errors in indentations will lead to misspecification of metadata information. (Usually, the next layer is 2 spaces or a tab towards the right.)

``` yaml
First.layer
  Second.layer
  Second.layer
    Third.layer
  Second.layer
First.layer
  Second.layer
```

Colons `:` are used to specify **key-value pairs**, i.e., an element of a certain name (key) as well as its corresponding value. Per line, only one key-value pair is specified. The basic syntax is `key: value`. Always include a space after the colon. Usually no quotation marks `""` are necessary when specifying values. Some exceptions are listed below. Almost all keys are pre-defined by `epicdata` to structure your metadata. The values usually must have a specific format, e.g. a number, or come from a list of allowed values. The values `yes` and `no` (similarly to `true` and `false`) will be transformed to `TRUE` and `FALSE` in R.

When to use quotation marks `""`:

-   By default, you don't need to wrap strings in quotation marks
-   Use them, however, if you start a value with a special symbol (non-letter and non-number) apart from dot `.` and underscore `_`
-   Use them, however, if the string is only a dot `"."`
-   Use them as well, if you want to force a value to be a string. The `calling.code` in the example below would be read as the positive number `33` without quotation marks.
-   The same rules apply to keys and values, i.e., the part in front and after the colon ``` "``key": "value" ```
-   If reading your metadata leads to a `Loading YAML metadata failed!` error with the line number of the problem's location, try wrapping it in quotation marks as your first debugging activity.

``` yaml
name: France
capital: Paris
population.million: 68
eu.member: yes
calling.code: "+33"
```

Instead of individual key-value pairs, you can also map other objects to a key, e.g., several key-value pairs. This is achived by using indentations. In the example below, the key-value pairs of `capital`, `population.million`, `eu.member`, and `calling.code` are mapped to the corresponding country. Notice that no values appear in the same line as the keys `France` and `Germany`, because the indented key-value pairs are mapped to it. In addition, `France` and `Germany` with their key-value pairs are mapped to `countries`.

``` yaml
countries:
  France:
    capital: Paris
    population.million: 68
    eu.member: yes
    calling.code: "+33"
  Germany:
    capital: Berlin
    population.million: 84
    eu.member: yes
    calling.code: "+49"
```

Dashes `-` are used to form **lists**. Even though the YAML language can be more complicated, we only use dashes for lists of values when you need to map multiple values to the same key. All values in the same list need to have the same indentation and all of them have a dash. For this, the two space indentation is replaced by one dash and one space (`- value`). In the example below, since France only has one city with more than one million inhabitants, the value is specified as an ordinary key-value pair. However, since Germany has four cities with more than one million inhabitants, we need to specify a list. Notice that the dash has the same indentation as `million.cities`, but due to the dash and the additional space, the values themselves (`Berlin`, `Hamburg`, etc.) are indented by two characters, as usual.

``` yaml
countries:
  France:
    capital: Paris
    population.million: 68
    eu.member: yes
    calling.code: "+33"
    million.cities: Paris
  Germany:
    capital: Berlin
    population.million: 84
    eu.member: yes
    calling.code: "+49"
    million.cities:
    - Berlin
    - Hamburg
    - Munich
    - Cologne
```

YAML code is not specified in R files but in special text files with file extension `.yml`. The `yml` files can be created by function `xx()` and edited in R Studio. Therefore, the use of R Studio is recommended. See `xx` for more information on how to create your metadata.

## Metadata design principles

-   Including a key without specifying a value is equal to not including the key at all.

``` yaml
options:
  study.name: epicdata
  id.var:
  load.from: folder
```

is equal to

``` yaml
options:
  study.name: epicdata
  load.from: folder
```

-   Not specifying a key contains information for some keys as it defaults to a pre-specified value. (See the end of this vignette for a complete list of defaults.)

-   Whenever useful, different spellings are offered, e.g., `date.format` and `format.date`.

## Components

In `epicdata`, metadata consists of several components:

-   `options`: A list of options specifying study information, e.g. `study.name`, selecting workflow modules, e.g. `double.entry`, and defining global variable defaults, e.g. `date.format`.
-   `var.list`: A list of all variables, where variable-specific information is specified.
-   `na.codes`: A list of codes that will represent missing values in the processed data set.
-   `contras`: A list of implausible combinations of values from two variables.

The components form the first layer of the metadata hierarchy. They are the only values specified in the first layer. Specify them with a colon and without any dashes. The components can be specified in any order. If you are not adding any values below a certain component, you can leave it out completely.

``` yaml
options:
  tbd
var.list:
  tbd
na.codes:
  tbd
contras:
  tbd
```

## Component: options

Options are key-value pairs below component `options`. List all key-value pairs on the second layer without any dashes. In the list of option keys below, allowed values for the corresponding key are found in the brackets after each key.

**Study information**

-   `study.name` (Text): A short name for your study that is used for project and file names. If missing, a generic name will be used instead.

-   `id.var` (Name of variable specified in `var.list`): The name of the ID variable, which is used to identify observations. Allowed are the variable names specified in `var.list` as `id`. Duplicate values in the ID variable are allowed only if `double.entry: yes`. If missing, a generic ID variable will be added temporarily. Mandatory when `double.entry: yes` or `id.pattern` has been specified.

-   `id.pattern` (Regular expression): A regex pattern that must be fulfilled for all values of the variable specified in `id.var`. Rows with non-matching IDs are excluded. **Surround with quotation marks**, e.g., `"[:digit:]{5}"`!

**Workflow module selection**

-   `id.list` ((boolean, i.e., `true`, `yes`, `false`, `no`):

-   `load.from` (one of: `folder`, `db`): Defines which code module for reading raw data is used. If `folder`, data is read from the `Input` folder in the project. If `db`, data is read from a database. If missing, defaults to `folder`.

-   `mc.handling` ():

-   `double.entry` (boolean, i.e., `true`, `yes`, `false`, `no`):

**Global variable defaults**

-   `date.format` or `format.date` (one of: `ymd`, `ydm`, `mdy`, `myd`, `dmy`, `dym`): Defines the default date format. The value specified here is used for all variables of `type: date` for which no individual `format` is defined in `var.list`. If all date variables have a format defined, `date.format` has no impact. In `epicdata`, `lubridate` functions are used to process dates. The possible values define the order of day (d), month (m) and year (y). See `lubridate::ymd()` for possible date formats that can be processed with these functions. Mandatory when there are variables of `type: date` and not all of them have key `format` defined in `var.list`. Do not use both `date.format` and `format.date`.

-   `time.format` or `format.time` (one of: `hms`, `hm`, `ms`):

-   `datetime.format` or `format.datetime` (one of: ):

-   `to.na` (Text):

-   `touch.na` (boolean, i.e., `true`, `yes`, `false`, `no`):

-   `to.factor` (boolean, i.e., `true`, `yes`, `false`, `no`):

``` yaml
options:
  study.name: epicdata
  id.var: id
  id.pattern: "[:digit:]{5}"
  date.format: dmy
```

## Component: var.list

The list of variables `var.list` is the core of the metadata and a mandatory part of it. List all key-value pairs on the second layer. The same keys are re-used for each variable. Use a dash for only the first key of every new variable. In the list of variable keys below, allowed values for the corresponding key are found in the brackets after each key. Many keys only apply to certain variable types. Do not specify keys that apply to other types of variables. The list below is structured by the type of variable the keys apply to.

**Keys that apply to all variables:**

-   `id` (a syntactically valid name, see `?make.names` for details): The name of the variable. `id` must be specified for every variable. All variable names in the data set must be specified either in `id` or in `old.id`.

-   `old.id` or `id.old` (a syntactically valid name, see `?make.names` for details): If you want to change the name of a variable, put the old name in `old.id` and the new name in `id`. All variable names in the data set must be specified either in `id` or in `old.id`. Cannot be used together with `new`.

-   `label` (Text):

-   `label.eng` (Text): If the label is not in English, enter its English translation here for use in the data dictionnary.

-   `type` (one of: `text`, `cat`, `num`, `date`, `time`, `datetime`):

-   `na.else` (a missing code): The missing code (as defined in component `na.codes`) specified here is used to replace `NA`s if no rule in `na.rules` applies. Must be specifed always, apart from situations when the variable has no `NA`s or when `touch.na` is set to `no`.

-   `to.na` (text):

-   `touch.na` (boolean, i.e., `true`, `yes`, `false`, `no`): If `no`, all `NA`s, after applying `to.na`, will remain as `NA`. If `yes`, `NA`s are processed as usual. Defaults to the global option `touch.na`, or, if the global options has not been specified, to `yes`.

-   `new` (): Create new variables based on existing variables by specifying `new`. If `new` is specified, `id` must not be in the data set. Also, `old.id` cannot be used. New variables are created with `dplyr::mutate()`, where the variable definition is specified as a name-value pair using tidy evaluation with data masking. For `new`, specify the value of this name-value pair. As an example, variable `mass_norm` would be created by `data.frame %>% mutate(mass_norm = mass / mean(mass, na.rm = TRUE))`. To recreate the creation of `mass_norm` in `epicdata`, `mass` must be a variable specified in `var.list`, `mass_norm` is the value for `id` for your new variable, while `mass / mean(mass, na.rm = TRUE)` is specified for `new`. If your value causes an error, try to wrap it in quotation marks.

``` yaml
var.list:
- id: mass
  ...
- id: mass_norm
  ...
  new: mass / mean(mass, na.rm = TRUE)
```

**Text variables:**

-   `ops` (a variable or mc.set name):
-   `dict` ():

**Categorical (cat) variables:**

-   `cats` ():

-   `cats.eng` ():

-   `to.factor` (boolean, i.e., `true`, `yes`, `false`, `no`): If `yes`, tranforms the variable to factor.

-   `factor.name` or `name.factor` (): If `to.factor` is `yes` or not specified, a new variable is created and turned to factor while this variable stays integer. Provide the name of the new factor variable.

-   `mc.set` (a syntactically valid name, see `?make.names` for details): cannot be a value used in any `id.var`,

**Numeric (num) variables:**

-   `from` ():

-   `from.exclude` ():

-   `to` ():

-   `to.exclude` ():

**Date variables:**

-   `format` or `date.format` or `format.date` ():

-   `from` ():

-   `from.exclude` ():

-   `to` ():

-   `to.exclude` ():

**Time variables:**

-   `format` or `time.format` or `format.time` ():

-   `from` ():

-   `from.exclude` ():

-   `to` ():

-   `to.exclude` ():

**Datetime variables:**

-   `format` or `datetime.format` or `format.datetime` ():

-   `from` ():

-   `from.exclude` ():

-   `to` ():

-   `to.exclude` ():

``` yaml
var.list:
- id:
  label:
```

## Component: na.codes

In the final processed datasets, NAs are usually replaced by missing codes. These codes represent a certain type or reason of missingness. In the component `na.codes`, certain values are declared as missing codes in order to allow `epicdata` to treat them appropriately, e.g., by including them in the data dictionary. In `na.codes`, no reference to certain variables is made yet. Here, only the declaration is done.

Every missing code is declared as one key-value pair with the code being the key and the description being the value.

``` yaml
na.codes:
  9001: Not answered
  9002: Not enough blood for analysis
  8001: Skipped because question is not applicable
  9001-01-01: Not answered (date)
  90h01m00s: Not answered (time hms)
```

The missing codes used in the final dataset must be of the same type (text, cat, num, date, datetime, time) as the variable. We therefore recommend to use integers, as they can be used in the same form for variables of type text, cat, and num. When an integer is used for date, datetime, or time, it is automatically transformed by the following rules:

**Single digit, e.g.,** `9`**:**

-   `date`: Add value in years to the date 9000-01-01, e.g., `9009-01-01`
-   `datetime`: Add value in years to the datetime 9000-01-01 00:00:00, e.g., `9009-01-01 00:00:00`
-   `time` (format: `hms`): Use the value in every digit, e.g., `99:99:99`, `99h99m99s`
-   `time` (format: `hm`): Use the value in every digit, e.g., `99:99`, `99h99m`
-   `time` (format: `ms`): Use the value in every digit, e.g., `99:99`, `99m99s`

**Two digits, e.g.,** `99`**:**

-   `date`: Add value in years to the date 9000-01-01, e.g., `9099-01-01`
-   `datetime`: Add value in years to the datetime 9000-01-01 00:00:00, e.g., `9099-01-01 00:00:00`
-   `time` (format: `hms`): Use the value for hours, minutes, and seconds, e.g., `99:99:99`, `99h99m99s`
-   `time` (format: `hm`): Use the value for hours and minutes, e.g., `99:99`, `99h99m`
-   `time` (format: `ms`): Use the value for minutes, and seconds, e.g., `99:99`, `99m99s`

**Three digits, e.g.,** `101`**:**

-   `date`: Add value in years to the date 9000-01-01, e.g., `9101-01-01`
-   `datetime`: Add value in years to the datetime 9000-01-01 00:00:00, e.g., `9101-01-01 00:00:00`
-   `time` (format: `hms`): Add the first digit in hours and the last two digits in minutes to the time 90:00:00, e.g., `91:01:00`, `91h01m00s`
-   `time` (format: `hm`): Add the first digit in hours and the last two digits in minutes to the time 90:00, e.g., `91:01`, `91h01m`
-   `time` (format: `ms`): Add the first digit in minutes and the last two digits in seconds to the time 90:00, e.g., `91:01`, `91m01s`

**Four digits, e.g.,** `9001`**:**

-   `date`: Use the value as the year of the date xxxx-01-01, e.g., `9001-01-01`
-   `datetime`: Use the value as the year of the datetime xxxx-01-01 00:00:00, e.g., `9001-01-01 00:00:00`
-   `time` (format: `hms`): Use the value for hours and minutes, e.g., `90:01:00`, `90h01m00s`
-   `time` (format: `hm`): Use the value for hours and minutes, e.g., `90:01`, `90h01m`
-   `time` (format: `ms`): Use the value for minutes, and seconds, e.g., `90:01`, `90m01s`

If the automatic transformation does not provide values that make sense for missing codes (values that cannot be confused with real values), you can provide date, datetime, and time values for missing codes as well. The values you choose must be in the same format as the corresponding variable, e.g., `9001-01-01` for format `ymd` and `01.01.9001` for format `dmy`. For time formats, we recommend using the letters `h` (for hours), `m` (for minutes), and `s` (for seconds) after the corresponding number, e.g., `90h01m00s`, `90h01m`, `01m00s`.

## Components: na.rules

## Components: contras

## Components: changes

## Defaults

Defaults are the values that are used if the key is not specified at all. Not all keys have defaults.

### options

| Key | Default |
|----|----|
| `study.name` | `my_study` |
| `id.var` | `id.var` (with values 1:N) |
| `id.pattern` | \- |
| `id.list` | `no` |
| `load.from` | `folder` |
| `consent` | `yes`, if `id.var` has been specified, otherwise `no` |
| `mc.handling` | `none` |
| `double.entry` | `no` |
| `date.format` or `format.date` | \- |
| `time.format` or `format.time` | \- |
| `datetime.format` or `format.datetime` | \- |
| `to.na` | \- |
| `touch.na` | `yes` |
| `to.factor` | `no` |

### var.list

| Key | Default |
|------------------------------------|------------------------------------|
| `id` | \- |
| `old.id` | \- |
| `label` | \- |
| `label.eng` | \- |
| `type` | \- |
| `na.else` | \- |
| `to.na` | option `to.na` |
| `touch.na` | option `touch.na` |
| `new` | \- |
| `ops` | `no` |
| `cats` | \- |
| `cats.eng` | \- |
| `to.factor` | yes, if `factor.name` or `name.factor` has been specified, otherwise option `to.factor` |
| `factor.name` or `name.factor` | \- |
| `from` | $-\infty$ (number, date, time, or datetime) |
| `from.exclude` | $-\infty$ (number, date, time, or datetime) |
| `to` | $\infty$ (number, date, time, or datetime) |
| `to.exclude` | $\infty$ (number, date, time, or datetime) |
| `format` or `date.format` or `format.date` | option `date.format` or `format.date` |
| `format` or `time.format` or `format.time` | option `time.format` or `format.time` |
| `format` or `datetime.format` or `format.datetime` | option `datetime.format` or `format.datetime` |
